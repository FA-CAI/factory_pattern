package com.shangxue.factory_pattern_me.abstractFactory;

import com.shangxue.factory_pattern_me.Milk;

/**
 * 抽象工厂时用户的主入口
 *
 * 由上文可知，咱们的痛点可以采用多态（统一管理）来解决，那么，
 * 既然是为了“方便统一管理”，为什么不设计成又一个接口，而是设计成一个抽象类呢？架构师们的设计想法是为了不仅有接口，而且能在里面写公共方法/公用逻辑（包含具体实现，可以储存一些公共的逻辑。这又可引申到类其实就是用来存储数据的嘛，软件本质：数据结构+算法……。）！所以，设计为抽象类而这儿不使用纯粹的接口来达到我们解决在工厂方法时发现的哪个痛点（客户程序员想要也不关心具体哪个工厂）的目的
 *这样，抽象类相比接口的优势是可以使得工厂：不仅"差异化定制"还能拥有存储"通用部分"的能力。
 * 而且，还可以直接new？？？（划掉，并没有，因为要用的方法（在这里是以接口形式存在/存储）的具体实现并没写）
 *
 * 把自己凭空记住名字，变成可以通过对象调方法，IDEA就会提示有哪些方法，这样减少背诵记忆量？
 */
//抽象工厂模式是在Spring中应用的最为广泛的一种设计模式 1.公共逻辑写在一起，方便管理 2.易于扩展（比如增加一个三鹿牌牛奶，你会发现api很容易升级（抽象工厂类里加个接口呗，就O了，虽然具体实现我还没写，但另一个程序员已经可以调用了，我是否实现完（不必等我，没有谁等谁，谁拖慢谁（当然，最后项目验收肯定就得等所有人都写完了负责的代码了），咱俩可以并发、异步coding啦~），他负责的那部分代码都不用改或者说改动极小，极大提高了协同开发的效率(我的后续是否实现不必影响别人的代码，解耦合~接口~，对于架构师(他当然可以也应该"修改"啦~不然谁修？他架构的诶，他动内部了修改内部~)和客户程序员(这程序里以Test.java模拟代表客户程序员)的关系而言，也符合开闭原则~)））
    //比如，Spring版本更新它的代码变动了，但是对于你而言，你调的接口名字入参和返回值类型都没动，这就是开闭原则和多态带给你这个Spring架构师的客户程序员的好处
public abstract class AbstractFactory {

    //通过吧工厂都给再抽象多态了一下，那么，用户不仅不用关心是怎么生产的，还不用关心是由谁生产的了耶

    /**
     * 获得光明牌牛奶
     */
    public abstract Milk getBrightDairy();
    /**
     * 获得蒙牛牌牛奶
     */
    public abstract Milk getMengniu();
    /**
     * 获得伊利牌牛奶
     */
    public abstract Milk getYili();



}

//那么，既然这里存在接口，肯定还需要一个实现类，具体实现产品的  PureMilkFactory （这角色好像就=共厂方法里"接口Factory"+"具体实现类MengniuFactory、YiliFactory、BrightDairyFactory"哦，哈哈哈），【从后续编码看来，的确是的】
// 那么，也就是你还得记实现类T_T，但是只要记一个了，其他通过智能编译器调方法看出来（这不就又是共产方法了吗AoA） 【其实，进化成抽象工厂模式不就是为了这个目的吗】
//听某老师说了又一个优点：记一个配置比记多个配置的好处：记多个时，你可能会出错会配置错(比如简单工厂时，我们通过return 报错信息，告诉他你配错了没这产品)...（现在我只要通过IDEA点出来（方法）...。用户只有选择的权利了（好像前端哦，能选的就别让他填，谁知道有些用户能多奇葩多乱来多蠢-_-||），保证了代码的健壮性）
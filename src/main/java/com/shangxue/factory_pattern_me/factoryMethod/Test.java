package com.shangxue.factory_pattern_me.factoryMethod;



public class Test {


    public static void main(String[] args) {

       Factory factory=new MengniuFactory();   //扩展时（比如买牛奶产品时，咱想货比三家，不知道谁好谁坏，喝喝伊利怎么样？），就是改这里的【配置】：比如让它变成new YiliFactory()

        System.out.println(factory.getMilk());  //蹭了一点多态的便宜。通过多态的优点（用父类接收具体实例），让事情变得稍微优雅了点(生产产品这事，变得不仅专业化而且规模化了)（但复杂度和没有工厂这不一样吗？摔o(╥﹏╥)o，坑爹呢这是，感觉像个发育一半的怪胎。——所以，又有了下一阶，工厂兽超进化：抽象工厂模式！）


    }
}

/**
 *工厂不通过名字去用了。而通过调用该特异工厂的该方法，也就是通过调方法来产生了，所以叫“工厂方法（对于我们客户程序员而言，就是调用方法来生成实例，具体怎么生成的，new啊反射啊，又有什么产品工序（杀毒啊过滤啊几层包装啊），不关心，初级程序员不关心过程！）”
 *
 *可是我还是不得知道工厂名字吗，和之前不用不用工厂时要记住具体产品的类名，似乎没有优越在哪啊，一样让客户程序员感觉复杂蛋疼啊，只是记具体实现类的名，变成了记具体实现工厂类的名，这不仍一样蛋疼吗
 *
 * 所以，用户能不能也不用关心是"哪个工厂"呢——那么，势必又是要利用多态来实现，把工厂又给再向上抽象抽取一次~因此，有了抽象工厂！
 */

/**利弊分析
 *
 * 优点：
 （1）工厂方法用来创建客户所需要的产品，同时隐藏了产品类生产的细节，用户只需要要关注工厂（不需要记各个实现类名，且把实现过程若有一些其他流程可以一并封装隐藏了[比如蒙牛要三次x射线消毒杀菌，伊利要四次γ射线消毒杀菌]，但要记各个工厂名了），不需要关注创建的细节。
 (2)在增加修改新的运算类的时候不用修改代码，只需要增加对应的工厂就好，完全符合开放——封闭性原则！
 （3）创建对象的细节完全封装在具体的工厂内部，而且有了抽象的工厂类，所有的具体工厂都继承了自己的父类！完美的体现了多态性！

 缺点：
 （1）在增加新的产品时（比如“三元”牛奶），也必须增加新的工厂类（客户程序员在他那边的代码才能够顺利继续编程下去），会带来额外的开销
 （2）划掉、存疑(抽象层的加入使得理解程度加大)
 (3)用户能不能也不用关心是"哪个工厂"呢
 *
 */